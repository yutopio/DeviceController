{
module Lexer

open Types
open Parser

open System
open System.Text

let lexeme (lexbuf:Lexing.LexBuffer<_>) = new string(lexbuf.Lexeme)
}

let newline = ['\r' '\n']
let space = [' ' '\t' '\r' '\n']
let digit = ['0'-'9']
let letter = ['a'-'z' 'A'-'Z']
let nonEscChars = [^ '"' '\'' '\\' '0' 'n' 'r' 't']
let identifierStartCharacter = letter | '_'
let identifierPartCharacter = letter | digit | '_'
let ident = identifierStartCharacter identifierPartCharacter*
let floatp = digit+ '.' digit*
let floate = digit+ ('.' digit* )? ('e'| 'E') ['+' '-']? digit+
let float = floatp | floate
let regularStrChar = [^ '\"' '\\' '\r' '\n']

rule token = parse
    | space+            { token lexbuf }
    | "//"              { lineComment lexbuf }
    | "/*"              { blockComment lexbuf }
    | "procedure"       { PROC }
    | "timeline"        { TIME }
    | "from"            { FROM }
    | "for"             { FOR }
    | "to"              { TO }
    | '+'               { PLUS }
    | '('               { LPAREN }
    | ')'               { RPAREN }
    | '{'               { LCBRACK }
    | '}'               { RCBRACK }
    | ','               { COMMA }
    | ';'               { SEMICOLON }
    | ident             { IDENT(lexeme lexbuf) }
    | digit+            { INT(Int32.Parse(lexeme lexbuf)) }
    | float             { FLOAT(Single.Parse(lexeme lexbuf)) }
    | '\"'              { STR(regularString "" lexbuf) }
    | "@\""             { STR(verbatimString "" lexbuf) }
    | eof               { EOF }
    | _                 { raise (new System.ApplicationException("Unrecognized token: " + (lexeme lexbuf))) }
and lineComment = parse
    | newline           { token lexbuf }
    | eof               { EOF }
    | _                 { lineComment lexbuf }
and blockComment = parse
    | "*/"              { token lexbuf }
    | [^'*''/']+        { blockComment lexbuf }
    | '*'+[^'*''/']     { blockComment lexbuf }
    | eof               { raise (new System.IO.EndOfStreamException("Reached to EOF. End of block comment '*/' expected.")) }
    | _                 { blockComment lexbuf }
and regularString str = parse
    | '\"'              { str }
    | "\\\""            { regularString (str + "\"") lexbuf }
    | "\\'"             { regularString (str + "\'") lexbuf }
    | "\\\\"            { regularString (str + "\\") lexbuf }
    | "\\0"             { regularString (str + "\000") lexbuf }
    | "\\n"             { regularString (str + "\n") lexbuf }
    | "\\r"             { regularString (str + "\r") lexbuf }
    | "\\t"             { regularString (str + "\t") lexbuf }
    | '\\' nonEscChars  { regularString (str + "\t") lexbuf }
    | newline           { raise (new System.IO.EndOfStreamException("Detected new line. End of string '\"' expected.")) }
    | regularStrChar+   { regularString (str + (lexeme lexbuf)) lexbuf }
    | eof               { raise (new System.IO.EndOfStreamException("Reached to EOF. End of string '\"' expected.")) }
and verbatimString str = parse
    | [^'"']+           { verbatimString (str + (lexeme lexbuf)) lexbuf }
    | "\"\""            { verbatimString (str + "\"") lexbuf }
    | '\"'              { str }
    | eof               { raise (new System.IO.EndOfStreamException("Reached to EOF. End of string '\"' expected.")) }
and preprocToken = parse
    | space+            { preprocToken lexbuf }
    | "#device"         { PP_DEVICE }
    | "#load"           { PP_LOAD }
    | "#priority"       { PP_PRIORITY }
    | "with"            { PP_WITH }
    | "as"              { PP_AS }
    | "high"            { PP_HIGH }
    | "for"             { PP_FOR }
    | ident             { IDENT(lexeme lexbuf) }
    | '('               { LPAREN }
    | ')'               { RPAREN }
    | ','               { COMMA }
    | digit+            { INT(Int32.Parse(lexeme lexbuf)) }
    | '\"'              { STR(regularString "" lexbuf) }
    | eof               { EOF }
    | _                 { raise (new System.ApplicationException("Unrecognized token: " + (lexeme lexbuf))) }
