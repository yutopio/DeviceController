{
module Lexer

open System
open System.Collections.Generic
open System.Text
open Parser

let mutable recursiveParseEntrypoint : (string -> Dictionary<string, Types.invokable>) = fun x -> null

let mutable internal identities : List<string> = null
let mutable internal deviceDefs : List<Types.device> = null
let mutable internal externProcs : Dictionary<Types.ident, Types.proc> = null
let mutable internal lastBreakPos = 0
let mutable internal priority = -1

let getState () = (identities, deviceDefs, externProcs, lastBreakPos, priority)
let setState (a, b, c, d, e) =
    identities <- a
    deviceDefs <- b
    externProcs <- c
    lastBreakPos <- d
    priority <- e
let initState () = setState (new List<string>(), new List<Types.device>(), new Dictionary<Types.ident, Types.proc>(), 0, -1)

(*** Some helper functions ***)
let lexeme (lexbuf:Lexing.LexBuffer<_>) = new string(lexbuf.Lexeme)
let spos (lexbuf:Lexing.LexBuffer<_>) = lexbuf.StartPos.AbsoluteOffset
let epos (lexbuf:Lexing.LexBuffer<_>) = lexbuf.EndPos.AbsoluteOffset

let eofSwitch func token lexbuf =
    if (func lexbuf) = 0 then token lexbuf else EOF

let newIdent lexbuf =
    let name = lexeme lexbuf
    let identID = identities.Count
    // This is an optimization that make use of ident = int. If you are going to
    // change type of ident in Types.fs, you have to change type of identities
    // to Dictionary<Types.ident, string>.
    identities.Add(name)
    IDENT(identID)

(*** Error definitions ***)
let error msg = raise (new System.ApplicationException(msg))
let ppPosError () = error "Preprocessor directives must appear as the first non-whitespace character on a line"
let ppEndError () = error "Single-line comment or end-of-line expected"
let unrecToken token = error ("Unrecognized token: " + token)
let unrecPP name = error ("Unrecognized preprocessor: #" + name)
let invalDevSpec () = error ("Invalid device configuration")
let invalExtName name = error ("Invalid external name: " + name)
let undefDev name = error ("Undefined device name: " + name)
let invalPriDur (dur:int) = error ("Invalid duration in #priority : " + dur.ToString())
let nonTermCom () = error "End-of-file found, '*/' expected"
let brStr () = error "Newline in string literal"
let eofStr () = error "Unterminated string literal"

(*** Needed for preprocessor appearance control (see ppPosError above) ***)
let updateBreakPos (lexbuf:Lexing.LexBuffer<_>) =
    if lastBreakPos = spos lexbuf then
        lastBreakPos <- epos lexbuf
let ppControl ppToken token lexbuf =
    if lastBreakPos = spos lexbuf then
        eofSwitch ppToken token lexbuf
    else ppPosError ()

(*** Preprocessor operations ***)
let preprocDevice (IDENT id) port (devSpec:int list) =
    let dev = new Types.device(id)
    if port <> null then
        dev.defined <- true
        dev.portName <- port
        if devSpec.Length >= 1 && devSpec.Length <= 4 then
            dev.baudRate <- devSpec.[0]
            dev.parity <- devSpec.[1]
            dev.dataBits <- devSpec.[2]
            dev.stopBits <- devSpec.[3]
        else
            invalDevSpec ()
    deviceDefs.Add(dev)

let preprocLoad file sub =
    let rec preprocLoadSub (info:Dictionary<string, Types.invokable>) sub =
        match sub with
        | [] -> ()
        | (oldName, newIdent) :: t ->
            if not (info.ContainsKey(oldName)) then
                invalExtName oldName
            let (IDENT newIdentID) = newIdent
            match info.[oldName] with
            | :? Types.proc as proc -> externProcs.Add(newIdentID, proc)
            | :? Types.device as device ->
                let newName = identities.[newIdentID]

                // Check existance of such a device with new name. Actually matching
                // device in following statement is not necessarily the exact device
                // that the program is pointing at.
                if not (deviceDefs.Exists(fun x -> identities.[x.id] = newName)) then
                    undefDev newName

                // If we made sure that the device actually exists, we don't need to
                // take any further action here.

            // Recursively interpret the rest of name substitutions
            preprocLoadSub info t
    preprocLoadSub (recursiveParseEntrypoint file) sub

let preprocPriority duration =
    if duration < -1 then
        invalPriDur duration
    priority <- duration
}

let br = ['\r' '\n']
let sp = [' ' '\t']
let digit = ['0'-'9']
let letter = ['a'-'z' 'A'-'Z']
let nonEscChars = [^ '"' '\'' '\\' '0' 'n' 'r' 't']
let identifierStartCharacter = letter | '_'
let identifierPartCharacter = letter | digit | '_'
let ident = identifierStartCharacter identifierPartCharacter*
let floatp = digit+ '.' digit*
let floate = digit+ ('.' digit* )? ('e'| 'E') ['+' '-']? digit+
let float = floatp | floate
let regularStrChar = [^ '\"' '\\' '\r' '\n']

rule token = parse
    | sp+               { updateBreakPos lexbuf; token lexbuf }
    | br+               { lastBreakPos <- epos lexbuf; token lexbuf }
    | '#'               { ppControl ppToken token lexbuf }
    | "//"              { eofSwitch lineComment token lexbuf }
    | "/*"              { eofSwitch blockComment token lexbuf }
    | "procedure"       { PROC }
    | "timeline"        { TIME }
    | "from"            { FROM }
    | "for"             { FOR }
    | "to"              { TO }
    | '+'               { PLUS }
    | '('               { LPAREN }
    | ')'               { RPAREN }
    | '{'               { LCBRACK }
    | '}'               { RCBRACK }
    | ','               { COMMA }
    | ';'               { SEMICOLON }
    | ident             { newIdent lexbuf }
    | digit+            { INT(Int32.Parse(lexeme lexbuf)) }
    | float             { FLOAT(Single.Parse(lexeme lexbuf)) }
    | '\"'              { STR(regularString "" lexbuf) }
    | "@\""             { STR(verbatimString "" lexbuf) }
    | eof               { EOF }
    | _                 { unrecToken (lexeme lexbuf) }
and lineComment = parse
    | br                { lastBreakPos <- epos lexbuf; 0 }
    | eof               { 1 }
    | _                 { lineComment lexbuf }
and blockComment = parse
    | "*/"              { 0 }
    | [^'*''/']+        { blockComment lexbuf }
    | '*'+[^'*''/']     { blockComment lexbuf }
    | eof               { nonTermCom (); 1 }
    | _                 { blockComment lexbuf }
and regularString str = parse
    | '\"'              { str }
    | "\\\""            { regularString (str + "\"") lexbuf }
    | "\\'"             { regularString (str + "\'") lexbuf }
    | "\\\\"            { regularString (str + "\\") lexbuf }
    | "\\0"             { regularString (str + "\000") lexbuf }
    | "\\n"             { regularString (str + "\n") lexbuf }
    | "\\r"             { regularString (str + "\r") lexbuf }
    | "\\t"             { regularString (str + "\t") lexbuf }
    | '\\' nonEscChars  { regularString (str + "\t") lexbuf }
    | br                { brStr () }
    | regularStrChar+   { regularString (str + (lexeme lexbuf)) lexbuf }
    | eof               { eofStr () }
and verbatimString str = parse
    | [^'"']+           { verbatimString (str + (lexeme lexbuf)) lexbuf }
    | "\"\""            { verbatimString (str + "\"") lexbuf }
    | '\"'              { str }
    | eof               { eofStr () }
and ppToken = parse
    | sp+               { ppToken lexbuf }
    | "device"     sp+  { ppDevice1 lexbuf }
    | "load"            { ppLoad1 lexbuf }
    | "priority"        { ppPriority1 lexbuf }
    | ident             { unrecPP (lexeme lexbuf) }
and ppDevice1 = parse
    | ident             { let name = newIdent lexbuf
                          let endState = ppEndCheck 1 lexbuf
                          if endState <> 2 then
                              (preprocDevice name null []; endState)
                          else
                              ppDevice2 name lexbuf }
and ppDevice2 id = parse
    | sp* '(' sp* '\"'  { ppDevice3 id (regularString "" lexbuf) [] lexbuf }
and ppDevice3 id port devSpec = parse
    | sp* ',' sp*       { ppDevice4 id port devSpec lexbuf }
    | sp* ')'           { preprocDevice id port devSpec; ppEndCheck 0 lexbuf }
and ppDevice4 id port devSpec = parse
    | digit+            { ppDevice3 id port (devSpec @ [Int32.Parse(lexeme lexbuf)]) lexbuf }
and ppLoad1 = parse
    | sp+ '\"'          { let file = regularString "" lexbuf
                          let endState = ppEndCheck 2 lexbuf
                          if endState <> 2 then (preprocLoad file []; endState) else ppLoad2 file [] lexbuf }
and ppLoad2 file sub = parse
    | sp* '(' sp*       { ppLoad3 file sub lexbuf }
and ppLoad3 file sub = parse
    | ident             { ppLoad4 file sub (lexeme lexbuf) lexbuf }
and ppLoad4 file sub old = parse
    | sp+ "as" sp+      { ppLoad5 file sub old lexbuf }
and ppLoad5 file sub old = parse
    | ident             { ppLoad6 file (sub @ [old, (newIdent lexbuf)]) lexbuf }
and ppLoad6 file sub = parse
    | sp* ')'           { let endState = ppEndCheck 3 lexbuf
                          if endState <> 2 then (preprocLoad file sub; endState) else ppLoad7 file sub lexbuf }
and ppLoad7 file sub = parse
    | sp* ','           { ppLoad2 file sub lexbuf }
and ppPriority1 = parse
    | sp+ "high"        { ppPriority2 lexbuf }
and ppPriority2 = parse
    | sp+ "for" sp+     { ppPriority3 lexbuf }
and ppPriority3 = parse
    | digit+            { preprocPriority (Int32.Parse(lexeme lexbuf)); ppEndCheck 0 lexbuf }
and ppEndCheck state = parse
    | sp* br            { lastBreakPos <- epos lexbuf; 0 }
    | sp* eof           { 1 }
    | sp* "//"          { lineComment lexbuf }
    | sp* '('           { if state = 1 then 2 else (ppEndError (); 0) }
    | sp* "with"        { if state = 2 then 2 else (ppEndError (); 0) }
    | sp* ','           { if state = 3 then 2 else (ppEndError (); 0) }
    | _                 { ppEndError (); 0 }
