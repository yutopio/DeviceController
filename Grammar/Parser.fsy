%{
module Parser

(****** Interface definition for Parser.fsi ******
open System.Collections.Generic
open Types

val mutable Devices : List<device>
val mutable Procs : Dictionary<string, proc>
val AddDevice : device -> int
val GetDevice : ident -> int

val InitState : unit -> unit
val SaveState : unit -> unit
val RestoreState : unit -> unit
*************************************************)

open System
open System.Collections.Generic
open Types

let ParseStack = new Stack<List<device> * Dictionary<string, int> * Dictionary<string, proc>>()

let mutable Devices : List<device> = null
let mutable DeviceDictionary : Dictionary<string, int> = null

let AddDevice device =
    let count = Devices.Count
    Devices.Add(device)
    DeviceDictionary.Add(device.name, count)
    count

let GetDevice ident =
    if DeviceDictionary.ContainsKey(ident) then
        DeviceDictionary.[ident]
    else
        let newDevice = new device()
        newDevice.name <- ident
        AddDevice newDevice

let mutable Procs : Dictionary<string, proc> = null

let GetProc ident =
    if Procs.ContainsKey(ident) then
        Procs.[ident]
    else
        let newProc = new proc()
        newProc.name <- ident
        Procs.Add(ident, newProc)
        newProc

let SetProc ident paramDef procBody =
    let target = GetProc ident
    if target.defined then
        raise (new ApplicationException("Procedure " + ident + " is already defined."))
    else
        target.defined <- true
        target.name <- ident
        target.parameters <- paramDef
        target.body <- procBody
        target

let InitState () =
    Devices <- new List<device>()
    DeviceDictionary <- new Dictionary<string, int>()
    Procs <- new Dictionary<string, proc>()

let SaveState () =
    ParseStack.Push((Devices, DeviceDictionary, Procs))

let RestoreState () =
    let (devices, deviceDictionary, procs) = ParseStack.Pop()
    Devices <- devices
    DeviceDictionary <- deviceDictionary
    Procs <- procs

%}

%token <string> IDENT
%token <string> STR
%token <int> INT
%token <single> FLOAT
%token PROC TIME
%token FROM FOR TO
%token PLUS
%token LPAREN RPAREN
%token LCBRACK RCBRACK
%token COMMA
%token SEMICOLON
%token EOF

%start compilationUnit
%type <Types.proc list> compilationUnit

%token PP_DEVICE
%token PP_LOAD PP_WITH PP_AS
%token PP_PRIORITY PP_HIGH PP_FOR

%start ppDirective
%type <Types.preproc> ppDirective

%%

compilationUnit:
    | EOF       { [] }
    | procs EOF { $1  }
;

procs:
    | procs procDef { $1 @ [$2] }
    | procDef       { [$1] }
;

procDef:
    | PROC IDENT paramDef procBody  { SetProc $2 $3 $4 }
;

paramDef:
    | LPAREN RPAREN             { [] }
    | LPAREN paramList RPAREN   { $2 }
;

paramList:
    | IDENT                 { [$1] }
    | paramList COMMA IDENT { $1 @ [$3] }
;

procBody:
    | timeline                      { [$1] }
    | procInvoke                    { [$1] }
    | LCBRACK RCBRACK               { [] }
    | LCBRACK procBodyBlock RCBRACK { $2 }
;

procBodyBlock:
    | timeline                  { [$1] }
    | procInvoke                { [$1] }
    | procBodyBlock timeline    { $1 @ [$2] }
    | procBodyBlock procInvoke  { $1 @ [$2] }
;

timeline:
    | TIME command                      { Time([$2]) }
    | TIME LCBRACK RCBRACK              { Time([]) }
    | TIME LCBRACK commandList RCBRACK  { Time($3) }
;

commandList:
    | command commandList   { $1 :: $2 }
    | command               { [$1] }
;

command:
    | IDENT arguments SEMICOLON             { Command((GetDevice $1), $2, None) }
    | IDENT arguments timeSpec SEMICOLON    { Command((GetDevice $1), $2, Some $3) }
;

timeSpec:
    | FROM INT                  { (Some $2, To $2) }
    | FOR INT                   { (None, For $2) }
    | TO INT                    { (None, To $2) }
    | FROM INT FOR INT          { (Some $2, For $4) }
    | FROM INT TO INT           { (Some $2, To $4) }
    | FROM INT FOR INT INT INT  { raise (new System.ApplicationException("Cannot specify both 'for' and 'to' time specification.")) }
    | FROM INT TO INT FOR INT   { raise (new System.ApplicationException("Cannot specify both 'for' and 'to' time specification.")) }
;

procInvoke:
    | IDENT arguments SEMICOLON { Proc((GetProc $1), $2) }
;

arguments:
    | LPAREN RPAREN         { [] }
    | LPAREN argList RPAREN { $2 }
;

argList:
    | expr COMMA argList    { $1 :: $3 }
    | expr                  { [$1] }
;

expr:
    | literal           { Const($1) }
    | expr PLUS expr    { Add($1, $3) }
;

literal:
    | IDENT     { Value $1 }
    | STR       { String $1 }
    | FLOAT     { Float $1 }
;

ppDirective:
    | PP_DEVICE ppDevice EOF        { $2 }
    | PP_LOAD ppLoad EOF            { $2 }
    | PP_PRIORITY ppPriority EOF    { $2 }
;

ppDevice:
    | IDENT                             { Device($1, None) }
    | IDENT LPAREN ppDeviceSpec RPAREN  { Device($1, Some $3) }
;

ppDeviceSpec:
    | STR COMMA INT                                 { ($1, [$3]) }
    | STR COMMA INT COMMA INT                       { ($1, [$3; $5]) }
    | STR COMMA INT COMMA INT COMMA INT             { ($1, [$3; $5; $7]) }
    | STR COMMA INT COMMA INT COMMA INT COMMA INT   { ($1, [$3; $5; $7; $9]) }
;

ppLoad:
    | STR                               { Load($1, []) }
    | STR PP_WITH ppLoadDeviceRenames   { Load($1, $3) }
;

ppLoadDeviceRenames:
    | ppLoadDeviceRenames COMMA ppLoadDeviceRename  { $1 @ [$3] }
    | ppLoadDeviceRename                            { [$1] }
;

ppLoadDeviceRename:
    | LPAREN IDENT PP_AS IDENT RPAREN   { ($2, $4) }
;

ppPriority:
    | PP_HIGH PP_FOR INT    { Priority($3) }
;
