%{
module Parser

(****** Interface definition for Parser.fsi ******
open System.Collections.Generic
open Types

val mutable Devices : List<device>
val mutable Procs : Dictionary<string, proc>
val AddDevice : device -> unit
val GetDevice : ident -> device
val SetExProc : ident -> int -> ident -> (device * device) list -> proc

val InitState : unit -> unit
val SaveState : unit -> unit
val RestoreState : unit -> unit
*************************************************)

open System
open System.Collections.Generic
open Types

(*** Contains all devices by order of DeviceID ***)
let mutable Devices : List<device> = null

(*** Keeps a list of current devices by name ***)
let mutable DeviceDictionary : Dictionary<string, device> = null

(*** Contains all procedures by name. They are all unique ***)
let mutable Procs : Dictionary<string, proc> = null

(*** Register a new device. It can override existing device by name ***)
let AddDevice device =
    Devices.Add(device)
    DeviceDictionary.[device.name] <- device

(*** Get the current DeviceID for the device with the specified name ***)
let GetDevice ident =
    if DeviceDictionary.ContainsKey(ident) then
        // If the device with the same name already exists, use it.
        DeviceDictionary.[ident]
    else if Procs.ContainsKey(ident) then
        raise (new InvalidProgramException("Procedure with the name " + ident + "already exists."))
    else
        // Otherwise create a new device with the name.
        let newDevice = new device()
        newDevice.defined <- false
        newDevice.name <- ident
        AddDevice newDevice
        newDevice

(*** Get a reference to the procedure with the specified name ***)
let GetProc ident =
    if Procs.ContainsKey(ident) then
        Procs.[ident]
    else if DeviceDictionary.ContainsKey(ident) then
        raise (new InvalidProgramException("Device with the name " + ident + "already exists."))
    else
        // If not exists, create one.
        let newProc = new proc()
        newProc.name <- ident
        Procs.Add(ident, newProc)
        newProc

(*** For invocation in normal context, get either device or proc ***)
let GetDeviceOrProc ident =
    if DeviceDictionary.ContainsKey(ident) then
        DeviceDictionary.[ident] :> invokable
    else
        GetProc ident :> invokable

(*** Register a procedure body that is not yet defined ***)
let SetProc ident paramDef procBody =
    let target = GetProc ident
    if target.defined then
        raise (new ApplicationException("Procedure " + ident + " is already defined."))
    else
        target.defined <- true
        target.name <- ident
        target.parameters <- paramDef
        target.body <- procBody
        target

(*** Register an external procedure ***)
let SetExProc ident file exname dev =
    let target = GetProc ident
    if target.defined then
        raise (new ApplicationException("Procedure " + ident + " is already defined."))
    else
        target.defined <- true
        target.name <- ident
        target.origin <- Some (file, exname)
        target.deviceBind <- dev
        target

(*** State tracking so that Parser can run multiple instances at once ***)
let ParseStack = new Stack<List<device> * Dictionary<string, device> * Dictionary<string, proc>>()

(*** Start a new parsing session ***)
let InitState () =
    Devices <- new List<device>()
    DeviceDictionary <- new Dictionary<string, device>()
    Procs <- new Dictionary<string, proc>()

(*** In order to start another parsing session, call this in advance ***)
let SaveState () =
    ParseStack.Push((Devices, DeviceDictionary, Procs))

(*** After finishing nester parsing session, call this to resume ***)
let RestoreState () =
    let (devices, deviceDictionary, procs) = ParseStack.Pop()
    Devices <- devices
    DeviceDictionary <- deviceDictionary
    Procs <- procs
%}

%token <string> IDENT
%token <string> STR
%token <int> INT
%token <single> FLOAT
%token PROC TIME
%token FROM FOR TO
%token PLUS
%token LPAREN RPAREN
%token LCBRACK RCBRACK
%token COMMA
%token SEMICOLON
%token EOF

%start compilationUnit
%type <Types.proc list> compilationUnit

%token PP_DEVICE
%token PP_LOAD PP_WITH PP_AS
%token PP_PRIORITY PP_HIGH PP_FOR

%start ppDirective
%type <Types.preproc> ppDirective

%%

compilationUnit:
    | EOF       { [] }
    | procs EOF { $1  }
;

procs:
    | procs procDef { $1 @ [$2] }
    | procDef       { [$1] }
;

procDef:
    | PROC IDENT paramDef procBody  { SetProc $2 $3 $4 }
;

paramDef:
    | LPAREN RPAREN             { [] }
//  | LPAREN paramList RPAREN   { $2 }  // NYI: Parameter for procedure
;

paramList:
    | IDENT                 { [$1] }
    | paramList COMMA IDENT { $1 @ [$3] }
;

procBody:
    | timeline                      { [$1] }
    | procInvoke                    { [$1] }
    | LCBRACK RCBRACK               { [] }
    | LCBRACK procBodyBlock RCBRACK { $2 }
;

procBodyBlock:
    | timeline                  { [$1] }
    | procInvoke                { [$1] }
    | procBodyBlock timeline    { $1 @ [$2] }
    | procBodyBlock procInvoke  { $1 @ [$2] }
;

timeline:
    | TIME command                      { Time([$2]) }
    | TIME LCBRACK RCBRACK              { Time([]) }
    | TIME LCBRACK commandList RCBRACK  { Time($3) }
;

commandList:
    | command commandList   { $1 :: $2 }
    | command               { [$1] }
;

command:
    | IDENT arguments SEMICOLON             { Command((GetDevice $1), $2, None) }
    | IDENT arguments timeSpec SEMICOLON    { Command((GetDevice $1), $2, Some $3) }
;

timeSpec:
    | FROM INT                  { (Some $2, To $2) }
    | FOR INT                   { (None, For $2) }
    | TO INT                    { (None, To $2) }
    | FROM INT FOR INT          { (Some $2, For $4) }
    | FROM INT TO INT           { (Some $2, To $4) }
    | FROM INT FOR INT INT INT  { raise (new System.ApplicationException("Cannot specify both 'for' and 'to' time specification.")) }
    | FROM INT TO INT FOR INT   { raise (new System.ApplicationException("Cannot specify both 'for' and 'to' time specification.")) }
;

procInvoke:
    | IDENT arguments SEMICOLON { Proc((GetDeviceOrProc $1), $2) }
;

arguments:
    | LPAREN RPAREN         { [] }
    | LPAREN argList RPAREN { $2 }
;

argList:
    | expr COMMA argList    { $1 :: $3 }
    | expr                  { [$1] }
;

expr:
    | literal           { Const($1) }
    | expr PLUS expr    { Add($1, $3) }
;

literal:
    | IDENT     { Value $1 }
    | STR       { String $1 }
    | FLOAT     { Float $1 }
;

ppDirective:
    | PP_DEVICE ppDevice EOF        { $2 }
    | PP_LOAD ppLoad EOF            { $2 }
    | PP_PRIORITY ppPriority EOF    { $2 }
;

ppDevice:
    | IDENT                             { Device($1, None) }
    | IDENT LPAREN ppDeviceSpec RPAREN  { Device($1, Some $3) }
;

ppDeviceSpec:
    | STR COMMA INT                                 { ($1, [$3]) }
    | STR COMMA INT COMMA INT                       { ($1, [$3; $5]) }
    | STR COMMA INT COMMA INT COMMA INT             { ($1, [$3; $5; $7]) }
    | STR COMMA INT COMMA INT COMMA INT COMMA INT   { ($1, [$3; $5; $7; $9]) }
;

ppLoad:
    | STR                               { Load($1, []) }
    | STR PP_WITH ppLoadDeviceRenames   { Load($1, $3) }
;

ppLoadDeviceRenames:
    | ppLoadDeviceRenames COMMA ppLoadDeviceRename  { $1 @ [$3] }
    | ppLoadDeviceRename                            { [$1] }
;

ppLoadDeviceRename:
    | LPAREN IDENT PP_AS IDENT RPAREN   { ($2, $4) }
;

ppPriority:
    | PP_HIGH PP_FOR INT    { Priority($3) }
;
